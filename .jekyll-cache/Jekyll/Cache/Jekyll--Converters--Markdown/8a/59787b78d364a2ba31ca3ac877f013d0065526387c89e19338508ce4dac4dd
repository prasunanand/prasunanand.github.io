I"\ì<h3 id="introduction">Introduction</h3>
<p>NMatrix for MRI has become a fairly well-established project. NMatrix is SciRuby‚Äôs numerical matrix core, implementing dense matrices as well as two types of sparse (linked-list-based and Yale/CSR). The backend has been written in C/C++ and relies on ATLAS/ CBLAS / CLAPACK and standard LAPACK for several of its linear algebra operations.</p>

<p>With JRuby + Truffle + Graal becoming very fast compared to MRI, a lot of ruby developers are switching to JRuby. JRuby compiles to byte code making it fast and also does heavy optimizations before and after generating byte code. However NMatrix does not run on JRuby because of C-libraries, and as a result they‚Äôre not usable on JRuby. The more of these libraries we have ports for, the less pain JRuby users suffer during migration.</p>

<p>This project aims to port NMatrix to JRuby. NMatrix being a huge library; we aim to implement NMatrix on Jruby for dense matrices during the summers. Every feature of NMatrix that has been ported to JRuby will be benchmarked versus NMatrix-CRuby.</p>

<h3 id="benchmarking">Benchmarking</h3>

<p>After the first iteration, we benchmarked NMatrix JRuby versus NMatrix CRuby for matrix addition, subtraction and multiplication and got some interesting results.</p>

<p><img src="/assets/iter1/add.png?raw=true" alt="Alt Matrix Addition" title="Fig.1. Matrix Addition" />
<img src="/assets/iter1/subt.png?raw=true" alt="Alt Matrix Subtraction" title="Fig.2. Matrix Subtraction" />
<img src="/assets/iter1/mult.png?raw=true" alt="Alt Matrix Multiplication" title="Fig.3. Matrix Multiplication" /></p>

<p>The results were promising but there was a huge scope for improvement. The following sections discuss how we built the new backend and how we optimized it after the first iteration.</p>

<h3 id="creating-a-new-backend">Creating a new backend</h3>

<p>The java backend aims to create a wrapper around Commons Maths. The Apache Commons Mathematics Library is a library of lightweight, self-contained mathematics and statistics components addressing the most common problems not available in the Java programming language or Commons Lang. It has a very good community support. We used Version: 3.6.1.</p>

<p>Like any other ruby gem with c extensions, the backend code lies within ext/ directory. The new java backend has been placed in ext/nmatrix_java/ directory.</p>

<p><strong>NMatrix Creation for arbitrary dimension:</strong>
We started with double dense matrices and as soon as double matrices are completely implemented; we will implement other data-types. The JNMatrix class stores the the NMatrix elements. The elements of a matrix are stored as a flat_array using the ArrayRealVector class provided by Commons Math. ArrayRealVector class provides methods for operations like addition, subtraction and multiplication. The function mapToSelf(Univariate function) maps a function to each element that facilitates using different element-wise operations like sin(), cos(), floor(), ceil().</p>

<p>When we have matrices of two dimensions, we use JNMatrixTwoD class. Whenever a new JNMatrix object is initialised the constructor checks if it is two dimensional. If true a JNMatrixTwoD object is initialised. Now we can operate on 2-D matrices. JNMatrixTwoD wraps Array2DRowRealMatrix and BlockRealMatrix. They store elements of the matrix in row major format. BlockRealMatrix implementation is specially designed to be cache-friendly.Square blocks are stored as small arrays and allow efficient traversal of data both in row major direction and columns major direction, one block at a time. This greatly increases performances for algorithms that use crossed directions loops like multiplication or transposition. 2D double matrices currently support determinants, inverse, isSymmetric? .</p>

<p>Connecting with the new backend
The nmatrix c extension uses lib/nmatrix/nmatrix.rb to connect the backend and frontend. It loads the nmatrix.so file. The shared objects act as a bridge between the c api and ruby frontend code. For java extensions; we created a lib/nmatrix/nmatrix_java.rb file that gets loaded only when java is detected as ruby platform.</p>

<p><em>lib/nmatrix/nmatrix.rb</em></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">jruby?</span>
  <span class="sr">/java/</span> <span class="o">===</span> <span class="no">RUBY_PLATFORM</span>
<span class="k">end</span>

<span class="k">if</span> <span class="n">jruby?</span>
    <span class="nb">require</span> <span class="s1">'nmatix_java.rb'</span>
<span class="k">else</span>
    <span class="nb">require</span> <span class="s2">"nmatrix.so"</span>
<span class="k">end</span>
</code></pre></div></div>

<p><em>lib/nmatrix/nmatrix_java.rb</em></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'java'</span>
<span class="nb">require_relative</span> <span class="s1">'../../ext/nmatrix_java/vendor/commons-math3-3.6.1.jar'</span>
<span class="nb">require_relative</span> <span class="s1">'../../ext/nmatrix_java/target/nmatrix.jar'</span>
</code></pre></div></div>

<p>The lib/nmatrix/nmatrix_java.rb file further creates a NMatrix class and binds it with java backend apis. This file is analogous to ruby_nmatrix.c where NMatrix class is defined along with the methods.</p>

<p>NMatrix JRuby doesn‚Äôt seem to be RAM friendly as it consumes a lot of RAM as compared to NMatrix-CRuby.</p>

<p>For 6GB RAM we can multiply 5000 x 5000 matrix with a 5000 x 5000 RAM.
To multiply a 6,000 x 6,000 matrix with a 6,000*6,000 matrix we need 10gb ram.</p>

<p>This is evident that error scales up as we scale up the size. For example initialization of a 6000 by 60000 matrix  takes 9.89 to 13 seconds.</p>

<p>For a RealMatrix interface, the type of matrix returned depends on the dimension. Below 2^12 elements (i.e. 4096 elements or 64*64 for a square matrix) which can be stored in a 32kB array,  a Array2DRowRealMatrix instance is built. Above this threshold a BlockRealMatrix instance is built.</p>

<p><strong>Block Size</strong>
In java applications, data is read from and written to disk in units known as blocks. The Block Size property specifies the number of bytes per block.</p>

<p>According to Commons Math a BlockRealMatrix is a</p>

<p>‚ÄúCache-friendly implementation of RealMatrix using a flat arrays to store square blocks of the matrix.
This implementation is specially designed to be cache-friendly. Square blocks are stored as small arrays and allow efficient traversal of data both in row major direction and columns major direction, one block at a time. This greatly increases performances for algorithms that use crossed directions loops like multiplication or transposition.</p>

<p>The size of square blocks is a static parameter. It may be tuned according to the cache size of the target computer processor. As a rule of thumbs, it should be the largest value that allows three blocks to be simultaneously cached (this is necessary for example for matrix multiplication). The default value is to use 52x52 blocks which is well suited for processors with 64k L1 cache (one block holds 2704 values or 21632 bytes). This value could be lowered to 36x36 for processors with 32k L1 cache.</p>

<p>The regular blocks represent BLOCK_SIZE x BLOCK_SIZE squares. Blocks at right hand side and bottom side which may be smaller to fit matrix dimensions. The square blocks are flattened in row major order in single dimension arrays which are therefore BLOCK_SIZE2 elements long for regular blocks. The blocks are themselves organized in row major order.</p>

<p>As an example, for a block size of 52x52, a 100x60 matrix would be stored in 4 blocks. Block 0 would be a double[2704] array holding the upper left 52x52 square, block 1 would be a double[416] array holding the upper right 52x8 rectangle, block 2 would be a double[2496] array holding the lower left 48x52 rectangle and block 3 would be a double[384] array holding the lower right 48x8 rectangle.
The layout complexity overhead versus simple mapping of matrices to java arrays is negligible for small matrices (about 1%). The gain from cache efficiency leads to up to 3-fold improvements for matrices of moderate to large size.‚Äù</p>

<p><strong>Initialialization of a matrix in NMatrix-jruby</strong></p>

<p><em>lib/nmatrix/nmatrix_java.rb</em></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span>
  <span class="vi">@shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">shape</span><span class="p">,</span><span class="n">shape</span><span class="p">]</span> <span class="k">unless</span> <span class="n">shape</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Array</span><span class="p">)</span>
  <span class="vi">@s</span> <span class="o">=</span> <span class="n">elements</span>
  <span class="vi">@nmat</span><span class="o">=</span> <span class="no">JNMatrix</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@shape</span><span class="p">,</span> <span class="vi">@elements</span> <span class="p">,</span> <span class="s2">"FLOAT32"</span><span class="p">,</span> <span class="s2">"DENSE_STORE"</span> <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p><em>ext/nmatrix_java/nmatrix/JNMatrix.java</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">JNMatrixTwoD</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">shape</span><span class="o">,</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">oneDArray</span><span class="o">){</span>
    <span class="n">set_rows</span><span class="o">(</span><span class="n">shape</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="n">set_cols</span><span class="o">(</span><span class="n">shape</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>

    <span class="k">this</span><span class="o">.</span><span class="na">nmat2d</span> <span class="o">=</span> <span class="nc">MatrixUtils</span><span class="o">.</span><span class="na">createRealMatrix</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">two_d_array_generator</span><span class="o">(</span><span class="n">shape</span><span class="o">,</span>         <span class="n">oneDArray</span><span class="o">));</span>
    <span class="k">this</span><span class="o">.</span><span class="na">nmat2dblock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BlockRealMatrix</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">two_d_array_generator</span><span class="o">(</span><span class="n">shape</span><span class="o">,</span>  <span class="n">oneDArray</span><span class="o">));</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">shape</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">shape</span><span class="o">[</span><span class="mi">1</span><span class="o">]){</span>
      <span class="n">solver</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LUDecomposition</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">nmat2d</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p><em>ext/nmatrix_java/nmatrix/JNMatrixTwoD.java</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">RealMatrix</span> <span class="nf">createRealMatrix</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">rows</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">columns</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">columns</span> <span class="o">&lt;=</span> <span class="mi">4096</span><span class="o">)</span> <span class="o">?</span>
                <span class="k">new</span> <span class="nf">Array2DRowRealMatrix</span><span class="o">(</span><span class="n">rows</span><span class="o">,</span> <span class="n">columns</span><span class="o">)</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">BlockRealMatrix</span><span class="o">(</span><span class="n">rows</span><span class="o">,</span> <span class="n">columns</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>
<p><em>lib/nmatrix/nmatrix_java.rb</em> ( Matrix Addition )</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">+</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">NMatrix</span><span class="p">))</span>
    <span class="c1">#check dimension</span>
    <span class="c1">#check shape</span>
    <span class="k">if</span> <span class="p">(</span><span class="vi">@dim</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="nf">dim</span><span class="p">)</span>
      <span class="k">raise</span> <span class="no">Exception</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"cannot add matrices with different dimension"</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="c1">#check shape</span>
  <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="n">dim</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="k">if</span> <span class="p">(</span><span class="vi">@shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="k">raise</span> <span class="no">Exception</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"cannot add matrices with different shapes"</span><span class="p">);</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">resultArray</span> <span class="o">=</span> <span class="vi">@nmat</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">nmat</span><span class="p">).</span><span class="nf">to_a</span>
  <span class="n">result</span> <span class="o">=</span> <span class="no">NMatrix</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">resultArray</span><span class="p">,</span>  <span class="ss">dtype: :int64</span><span class="p">)</span>
  <span class="k">else</span>
  <span class="n">resultArray</span> <span class="o">=</span> <span class="vi">@nmat</span><span class="p">.</span><span class="nf">mapAddToSelf</span><span class="p">(</span><span class="n">other</span><span class="p">).</span><span class="nf">to_a</span>
  <span class="n">result</span> <span class="o">=</span> <span class="no">NMatrix</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">resultArray</span><span class="p">,</span>  <span class="ss">dtype: :int64</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">result</span>
<span class="k">end</span>
</code></pre></div></div>

<p><em>lib/nmatrix/nmatrix_java.rb</em> ( Matrix Multiplication )</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">NMatrix</span><span class="p">))</span>
    <span class="c1">#check dimension</span>
    <span class="c1">#check shape</span>
    <span class="k">if</span> <span class="p">(</span><span class="vi">@shape</span><span class="p">.</span><span class="nf">length!</span><span class="o">=</span><span class="mi">2</span> <span class="o">||</span> <span class="n">other</span><span class="p">.</span><span class="nf">shape</span><span class="p">.</span><span class="nf">length!</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
      <span class="k">raise</span> <span class="no">Exception</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"please convert array to nx1 or 1xn NMatrix first"</span><span class="p">)</span>
      <span class="k">return</span> <span class="kp">nil</span>
    <span class="k">end</span>
    <span class="k">if</span> <span class="p">(</span><span class="vi">@shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">raise</span> <span class="no">Exception</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"incompatible dimensions"</span><span class="p">)</span>
      <span class="k">return</span> <span class="kp">nil</span>
    <span class="k">end</span>
    <span class="n">resultArray</span> <span class="o">=</span> <span class="vi">@nmat</span><span class="p">.</span><span class="nf">twoDMat</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">nmat</span><span class="p">.</span><span class="nf">twoDMat</span><span class="p">).</span><span class="nf">to_a</span>
    <span class="n">newShape</span><span class="o">=</span> <span class="p">[</span><span class="vi">@shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">other</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="no">NMatrix</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">newShape</span><span class="p">,</span> <span class="n">resultArray</span><span class="p">,</span>  <span class="ss">dtype: :int64</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="k">raise</span> <span class="no">Exception</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"cannot have dot product with a scalar"</span><span class="p">);</span>
  <span class="k">end</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></div>

<p><em>ext/nmatrix_java/nmatrix/JNMatrixTwoD.java</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">double</span><span class="o">[]</span> <span class="nf">multiply</span><span class="o">(</span><span class="nc">JNMatrixTwoD</span> <span class="n">other</span><span class="o">){</span>
  <span class="nc">RealMatrix</span> <span class="n">result</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">nmat2d</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="n">other</span><span class="o">.</span><span class="na">nmat2d</span><span class="o">);</span>
  <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">one_d_array_generator</span><span class="o">(</span><span class="n">rows</span><span class="o">,</span> <span class="n">cols</span><span class="o">,</span> <span class="n">result</span><span class="o">.</span><span class="na">getData</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Lets take a look at what happens when we benchmark matrix multiplication.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shapeArray</span> <span class="o">=</span> <span class="p">[</span>
              <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">],</span>                      <span class="sr">//</span> <span class="n">array2dRowRealMatrix</span>
              <span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">],[</span><span class="mi">500</span><span class="p">,</span><span class="mi">500</span><span class="p">],</span> 
              <span class="p">[</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">],[</span><span class="mi">2000</span><span class="p">,</span><span class="mi">2000</span><span class="p">],[</span><span class="mi">3000</span><span class="p">,</span><span class="mi">3000</span><span class="p">],</span>  <span class="sr">//</span> <span class="no">BlockRealMatrix</span>
              <span class="p">[</span><span class="mi">4000</span><span class="p">,</span><span class="mi">4000</span><span class="p">],[</span><span class="mi">5000</span><span class="p">,</span><span class="mi">5000</span><span class="p">],</span>
            <span class="p">]</span>
</code></pre></div></div>

<p>For shape = [5000,5000] we generate an array of random elements.</p>

<p>RAM size calculation for storing a single matrix of 5,000 x 5,000 elements.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      5000*5000 =&gt; 5000/52 x 5000/52

   =&gt; 97x97 blocks x 21.632KB (Since,1 block of 2704 elements takes 21.362KB space.)

   =&gt; 203,535KB=&gt;203MB=&gt; 0.2GB

    Real array=&gt;  Three arrays of shape 5,000 x 5,000 =&gt;0.2 x 3 = 0.6GB.

    Multiplication =&gt; Three matrices of shape 5,000 x 5,000 =&gt;0.2 x 3 = 0.6GB.
</code></pre></div></div>

<p>In the process, while using multiplication api, commons math creates its own copy which consumes 0.2gb more.
Memory required is at least 1.6gb</p>

<p>Three initializations =&gt; 3 x 0.6GB + 0.6GB =&gt; 2.4GB &lt;= java copy</p>

<p>Ruby copy would be storing the elements =&gt; 0.6GB }&lt;= ruby copy
This calculation thus requires 3 GB.</p>

<p><strong>Pass by Value and Pass by reference</strong>
In the current code ,The input array is copied, not referenced at a lot of places. This consumes a lot of memory, upsets the Garbage Collector and slows down the program.</p>

<p><strong>Solution</strong></p>

<ol>
  <li>Minimise initializations</li>
  <li>Don‚Äôt copy again and again</li>
</ol>

<p>We need to work only in terms of apis provided by Commons-Math.jar</p>

<p><strong>After 2nd Iteration</strong>
We benchmarked the code after a few improvements. These are the new graphs that we obtained.</p>

<p><img src="/assets/iter2/add.png?raw=true" alt="Alt Matrix Addition" title="Fig.1. Matrix Addition" />
<img src="/assets/iter2/subt.png?raw=true" alt="Alt Matrix Subtraction" title="Fig.2. Matrix Subtraction" />
<img src="/assets/iter2/mult.png?raw=true" alt="Alt Matrix Multiplication" title="Fig.3. Matrix Multiplication" /></p>

<p>Instead of using a separate java class to store NMatrix element we used it directly in nmatrix_java.rb.  Now we don‚Äôt load nmatrix.jar.</p>

<p><em>lib/nmatrix/nmatrix_java.rb</em></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span>
  <span class="vi">@shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">shape</span><span class="p">,</span><span class="n">shape</span><span class="p">]</span> <span class="k">unless</span> <span class="n">shape</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Array</span><span class="p">)</span>
  <span class="vi">@s</span> <span class="o">=</span> <span class="no">ArrayRealVector</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">shape</span><span class="p">.</span><span class="nf">length</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="vi">@twoDMat</span> <span class="o">=</span> <span class="n">get_twoDMat</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span><span class="n">elements</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<p>Now there are just two initializations (only 1 if we don‚Äôt have 2D Matrix). Also, there is less ‚Äúpassing by value‚Äù to functions.</p>

<p><em>lib/nmatrix/nmatrix_java.rb</em> ( Matrix Addition )</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">+</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="no">NMatrix</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:copy</span><span class="p">)</span>
  <span class="n">result</span><span class="p">.</span><span class="nf">shape</span> <span class="o">=</span> <span class="vi">@shape</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">NMatrix</span><span class="p">))</span>
    <span class="c1">#check dimension</span>
    <span class="c1">#check shape</span>
    <span class="k">if</span> <span class="p">(</span><span class="vi">@dim</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="nf">dim</span><span class="p">)</span>
      <span class="k">raise</span> <span class="no">Exception</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"cannot add matrices with different dimension"</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="c1">#check shape</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="n">dim</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
      <span class="k">if</span> <span class="p">(</span><span class="vi">@shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">raise</span> <span class="no">Exception</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"cannot add matrices with different shapes"</span><span class="p">);</span>
      <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">result</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="vi">@s</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">s</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">result</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="vi">@s</span><span class="p">.</span><span class="nf">mapAddToSelf</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">result</span>
<span class="k">end</span>
</code></pre></div></div>

<p><em>lib/nmatrix/nmatrix_java.rb</em> ( Matrix Multiplication )</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">NMatrix</span><span class="p">))</span>
    <span class="c1">#check dimension</span>
    <span class="k">if</span> <span class="p">(</span><span class="vi">@shape</span><span class="p">.</span><span class="nf">length!</span><span class="o">=</span><span class="mi">2</span> <span class="o">||</span> <span class="n">other</span><span class="p">.</span><span class="nf">shape</span><span class="p">.</span><span class="nf">length!</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
      <span class="k">raise</span> <span class="no">Exception</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"please convert array to nx1 or 1xn NMatrix first"</span><span class="p">)</span>
      <span class="k">return</span> <span class="kp">nil</span>
    <span class="k">end</span>
    <span class="c1">#check shape</span>
    <span class="k">if</span> <span class="p">(</span><span class="vi">@shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">raise</span> <span class="no">Exception</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"incompatible dimensions"</span><span class="p">)</span>
      <span class="k">return</span> <span class="kp">nil</span>
    <span class="k">end</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="no">NMatrix</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:copy</span><span class="p">)</span>
    <span class="n">result</span><span class="p">.</span><span class="nf">shape</span> <span class="o">=</span> <span class="vi">@shape</span>
    <span class="n">result</span><span class="p">.</span><span class="nf">twoDMat</span> <span class="o">=</span> <span class="vi">@twoDMat</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">twoDMat</span><span class="p">)</span>
    <span class="n">result</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="no">ArrayRealVector</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">get_oneDArray</span><span class="p">(</span><span class="vi">@shape</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="nf">twoDMat</span><span class="p">.</span><span class="nf">getData</span><span class="p">()))</span>
  <span class="k">else</span>
    <span class="k">raise</span> <span class="no">Exception</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"cannot have dot product with a scalar"</span><span class="p">);</span>
  <span class="k">end</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We generate minimum number of copies. In binary and unary operations, the resultant matrix is initialized as a blank nmatrix. We then just point the result of the operation to the storage. So, the JRuby virtual machine doesn‚Äôt have to create new copies and the Garbage collector is not upset at all. Thus we see, a great deal of performance boost.</p>

<h3 id="autoboxing">Autoboxing</h3>
<p>Also passing values means coercing them in the required format. Now we don‚Äôt have to worry a lot about coercion of values.</p>

<h3 id="results">Results</h3>
<p>From the above graphs, we see that for addition and subtraction, NMatrix- JRuby is the clear winner.
NMatrix- Lapacke is the clear winner in matrix multiplication. NMatrix-Jruby competes closely with NMatrix-MRI. We can still optimize it to perform better, especially matrix multiplication.</p>

<h3 id="tests">Tests</h3>
<p>We used the existing tests for NMatrix-MRI for the development. The program detects on runtime which method to load.</p>

<p>The table given below summarises how many tests succeed currentlyusing NMatrix-jruby.</p>

<table>
  <thead>
    <tr>
      <th>Spec file</th>
      <th style="text-align: center">Total Test</th>
      <th style="text-align: center">Success</th>
      <th style="text-align: center">Failure</th>
      <th style="text-align: center">Pending</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>00_nmatrix_spec</td>
      <td style="text-align: center">188</td>
      <td style="text-align: center">80</td>
      <td style="text-align: center">102</td>
      <td style="text-align: center">6</td>
    </tr>
    <tr>
      <td>02_slice_spec</td>
      <td style="text-align: center">144</td>
      <td style="text-align: center">20</td>
      <td style="text-align: center">120</td>
      <td style="text-align: center">¬†</td>
    </tr>
    <tr>
      <td>03_nmatrix_monkeys_spec</td>
      <td style="text-align: center">12</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">¬†</td>
    </tr>
    <tr>
      <td>elementwise_spec</td>
      <td style="text-align: center">38</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">34</td>
      <td style="text-align: center">¬†</td>
    </tr>
    <tr>
      <td>math_spec</td>
      <td style="text-align: center">737</td>
      <td style="text-align: center">110</td>
      <td style="text-align: center">598</td>
      <td style="text-align: center">¬†</td>
    </tr>
    <tr>
      <td>shortcuts_spec</td>
      <td style="text-align: center">81</td>
      <td style="text-align: center">21</td>
      <td style="text-align: center">60</td>
      <td style="text-align: center">¬†</td>
    </tr>
    <tr>
      <td>stat_spec</td>
      <td style="text-align: center">72</td>
      <td style="text-align: center">28</td>
      <td style="text-align: center">54</td>
      <td style="text-align: center">¬†</td>
    </tr>
  </tbody>
</table>

<h3 id="improvements-and-future-work">Improvements and future work</h3>
<p>Implement solvers for two dimensional matrices and enumerators by the end of mid term and parallely optimize these features.
After mid-term evaluations, we will be implementing complex dtype using FieldRealVector and FieldMatrix followed by other data-types.</p>

<div id="disqus_thread"></div>
<script>
/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//prasunanandblog.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
:ET