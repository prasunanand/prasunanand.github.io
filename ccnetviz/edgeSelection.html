the pseudo code.
<html>
	<head>
		<title>Edge</title>
		<link rel="stylesheet" type="text/css" href="css/normalize.css">
		<link rel="stylesheet" type="text/css" href="css/home.css">
	</head>
	<body>
		<div class="container">
			<div class="row">
				<h1>Pseudo Code</h1>
				<div class="code">
					<pre>
					<code>
function is_edge_in_quad(quad, edge){
	// edge is connecting node a and b with coordinates (a1, a2) and (b1, b2)
	// We have quad_range as a 4-tuple.
	quad_range = (quad.xmin, quad.ymin, quad.xmax, quad.ymax)
	// We also have edge_range as a 4-tuple.
	edge_range = (edge.xmin, edge.ymin, edge.xmax, edge.ymax)
	// If both ranges are mutually exclusive, then the egde will not be in the quad, otherwise yes.
	return is_mutually_exclusive(quad_range, edge_range)
}


function is_mutually_exclusive(range1, range2){	
	// range1 = (x1, y1, x2, y2) , x1 <= x2 , y1 <= y2
	// range2 = (a1, b1, a2, b2) , a1 <= a2 , b1 <= b2	
	if ((x2 < a1) | (a1 < x2)){
		if ((y2 < b1) | (y1 < b2)) {
			return True
		}
	} 
	else {
		return False
	}
}

//////////////////////////////////////////////////////////////////////////
//edge quadtree
ccNetViz.quadtreeEdge = function(edges) {
    var d, xs, ys, i, n, x1_, y1_, x2_, y2_;

    console.log(edges);
    //range define

    x2_ = y2_ = -(x1_ = y1_ = Infinity);
    sxs = [], sys = [];
    txs = [], tys = [];
    n = edges.length;

    //define range on the basis of coordinates

    for (i = 0; i < n; ++i) {
        d = edges[i].source;
        if (d.x < x1_) x1_ = d.x;
        if (d.y < y1_) y1_ = d.y;
        if (d.x > x2_) x2_ = d.x;
        if (d.y > y2_) y2_ = d.y;
        sxs.push(d.x);
        sys.push(d.y);
    }
    for (i = 0; i < n; ++i) {
        d = edges[i].target;
        if (d.x < x1_) x1_ = d.x;
        if (d.y < y1_) y1_ = d.y;
        if (d.x > x2_) x2_ = d.x;
        if (d.y > y2_) y2_ = d.y;
        txs.push(d.x);
        tys.push(d.y);
    }
    //calculate distance between min and max for x and y

    var dx = x2_ - x1_;
    var dy = y2_ - y1_;

    //make a square

    dx > dy ? y2_ = y1_ + dx : x2_ = x1_ + dy;

    //create a leaf node

    function create() {
        return {
            leaf: true,
            nodes: [],
            edge: null,
            x: null,
            y: null
        };
    }

    //check if point is there in the quadrant
    //take a square
    //along its diagonal lie (x1,y1) and (x2,y2)
    //find the center of diagonal (sx,sy)
    //now we have four squares
    //top-left top-right bottom-left bottom-right
    //node(parent) has nodes(children) array


    function visit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * 0.5;
            var sy = (y1 + y2) * 0.5;
            var children = node.nodes;

            if (children[0]) visit(f, children[0], x1, y1, sx, sy);
            if (children[1]) visit(f, children[1], sx, y1, x2, sy);
            if (children[2]) visit(f, children[2], x1, sy, sx, y2);
            if (children[3]) visit(f, children[3], sx, sy, x2, y2);
        }
    }

    //start inserting
    //if n is a leaf and not an internal node
    //get nx and ny
    //n is a set of edges

    function insert(n, d, sx, sy, tx, ty, x1, y1, x2, y2) {
        if (n.leaf) {
            var nsx = n.sx;
            var nsy = n.sy;

            if (nsx !== null) {
                if (nsx === sx && nsy === sy) {
                    insertChild(n, d, sx, sy, tx, ty, x1, y1, x2, y2);
                }
                else {
                    var nEdge = n.edge;
                    n.sx = n.sy = n.edge = null;
                    ntx=nty=0;
                    insertChild(n, nEdge, nsx, nsy, ntx,nty, x1, y1, x2, y2);
                    insertChild(n, d, sx, sy, tx, ty, x1, y1, x2, y2);
                }
            } else {
                n.sx = sx, n.sy = sy, n.tx = tx, n.ty = ty, n.edge = d;
            }
        } else {
            insertChild(n, d, sx, sy, tx, ty, x1, y1, x2, y2);
        }
    }

    //start inserting children

    function insertChild(n, d, sx, sy, tx, ty, x1, y1, x2, y2) {
    //find the midpoint of diagonal
        var xm = (x1 + x2) * 0.5;
        var ym = (y1 + y2) * 0.5;
    //check if point is in the right quadrants(0 or 1)
        var right = sx >= xm;
    //check if point is in the lower quadrants (0 or 1)
        var below = sy >= ym;
    //generates quad tree quadrant value
        var i = below << 1 | right;
    //not an internal node
        n.leaf = false;

        n = n.nodes[i] || (n.nodes[i] = create());

        right ? x1 = xm : x2 = xm;
        below ? y1 = ym : y2 = ym;
        insert(n, d, sx, sy, tx, ty, x1, y1, x2, y2);
    }

    function findNode(root, x, y, x0, y0, x3, y3) {
        //initiliase min distance
        var minDistance2 = Infinity;
        var closestPointEdge;

        (function find(node, x1, y1, x2, y2) {

            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;

            if (edge = node.edge) {
                var edge;
                var dx = x - node.x;
                var dy = y - node.y;
                var distance2 = dx * dx + dy * dy;

                if (distance2 < minDistance2) {
                    var distance = Math.sqrt(minDistance2 = distance2);
                    x0 = x - distance, y0 = y - distance;
                    x3 = x + distance, y3 = y + distance;
                    closestEdge = edge;
                }
            }

            var children = node.nodes;
            var xm = (x1 + x2) * .5;
            var ym = (y1 + y2) * .5;
            var right = x >= xm;
            var below = y >= ym;

            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
                if (node = children[i & 3]) switch (i & 3) {
                    case 0: find(node, x1, y1, xm, ym); break;
                    case 1: find(node, xm, y1, x2, ym); break;
                    case 2: find(node, x1, ym, xm, y2); break;
                    case 3: find(node, xm, ym, x2, y2); break;
                }
            }
        })(root, x0, y0, x3, y3);

        return closestEdge;
    }

    //create the root nodes
    //Note: the root node is a leaf node.

    var root = create();
    //root.visit = function(f)  {return visit(f, root, x1_, y1_, x2_, y2_);};
    //root.find = function(x, y)  {return findNode(root, x, y, x1_, y1_, x2_, y2_);};

    //inserting children in the roots;

    for (i = 0; i < n; i++) {
            insert(root, edges[i], sxs[i], sys[i],txs[i], tys[i], x1_, y1_, x2_, y2_);
        }

    --i;

    xs = ys = edges = d = null;

    return root;
}; 
			</code>
					</pre>
				</div>
			</div>
		</div>
	</body>
</html>