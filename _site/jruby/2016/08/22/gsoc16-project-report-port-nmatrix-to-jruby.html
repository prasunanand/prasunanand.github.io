<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@300;400;500;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css"/>

    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/css/animate.css">
    <link rel="stylesheet" type="text/css" href="/css/style.css">
    <link rel="stylesheet" type="text/css" href="/css/responsive.css">

    <link rel="icon" href="/images/zasper_logo.ico" type="image/gif" sizes="32x32">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VRJB8WTXR1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-VRJB8WTXR1');
    </script>

    <title>Prasun's Blog</title>
  </head>
  <body>
    <section id="header-home">
      <nav class="navbar navbar-expand-lg">
        <div class="container">
          <a class="navbar-brand" href="/">
            <!-- <img src="images/logo.svg" alt="#"> -->
            Prasun's blog
          </a>
          <button class="navbar-toggler" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasMenu">
            <i class="fa fa-bars"></i>
          </button>
          <div class="navbar-collapse justify-content-center offcanvas offcanvas-top offcanvas-body" id="offcanvasMenu">
            <button type="button" class="colse-btn" data-bs-dismiss="offcanvas">
              <i class="fa fa-times"></i>
            </button>
            <div class="menu-right-btn mobile-menu-login-signup">
              <a href="/about" class="custom-btn btn-bg hover-bg">About</a>
            </div>
          </div>
          <div class="menu-right-btn justify-content-end">
            <a href="/about" class="custom-btn btn-bg hover-bg">About</a>
          </div>
        </div>
      </nav>
    </section>



    <section id="blog-sec">
      <div class="container">
        <div class="row">
          <div class="col-12 col-md-12 col-lg-9">
            <div class="blog-details-wraper">
              <div class="blog-main-image wow fadeInUp">
                <img src="/images/banner.png" alt="#">
              </div>

              <div class="blog-title wow fadeInUp">
                <h2>GSoC 2016: Port NMatrix to JRuby</h2>
              </div>

              <div class="blog-published-info wow fadeInUp">
                <span class="blog-post-date">22 August 2016 by</span>
                <span class="blog-post-author">Prasun Anand</span>
              </div>

              <div class="blog-description wow fadeInUp">
              	<p><h2 id="introduction"><strong>Introduction</strong></h2>

<p>I have been working on “Port NMatrix to JRuby” as my GSoC project. I am pleased to announce that <strong>JRuby is ready for Nmatrix users</strong>.</p>

<p>NMatrix, a linear algebra library wraps Apache Commons Maths for its core functionalities. By the end of GSoC, I have been able to implement NMatrix for dense matrices with double and object ( ruby objects ) data type. I have also worked on porting mixed-models gem to JRuby which heavily uses NMatrix at its core.</p>

<p>This blog post summarizes my work on the project with Sciruby, and reports the final status of the project.</p>

<h2 id="proposal"><strong>Proposal</strong></h2>

<p>The proposal application can be found <a href="https://docs.google.com/document/d/1EOvrH8AgYReVSmX8IsSYX8fl9CtJfHRDIgBsuMqeSIU/">here</a>.</p>

<h2 id="code-commits"><strong>Code Commits</strong></h2>

<p><a href="https://github.com/prasunanand/nmatrix/commits/jruby_port">https://github.com/prasunanand/nmatrix/commits/jruby_port</a></p>

<h2 id="storing-n-dimensional-matrices-as-flat-arrays"><strong>Storing n-dimensional matrices as flat arrays</strong></h2>

<p>The major components of a NMatrix is its shape, elements, dtype and stype. Any nmatrix when initialised, the elements are stored in flat arrays. ArrayRealVector class is used to store the elements.</p>

<p>@s stores the elements, @shape stores the shape of array, while @dtype and @stype store the data type and storage type respectively. currently, we have nmatrix-jruby implemented for only double matrices.</p>

<p>NMatrix-MRI uses @s which is an object containing elements, stride, offset as in C, we need to deal with the memory allocation for the arrays.</p>

<p><img src="/assets/report/nmatrix.png?raw=true" alt="NMatrix" title="Fig.1. NMatrix" /></p>

<h2 id="slicing-and-rank"><strong>Slicing and Rank</strong></h2>

<p>Implementing slicing was the toughest part of NMatrix-JRuby implementation.
NMatrix@s stores the elements of a matrix as a flat_array. The elements along any dimension are accessed with the help of the stride. NMatrix#get_stride calculates the stride with the help of the dimension and shape and returns an array.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_stride</span><span class="p">(</span><span class="n">nmatrix</span><span class="p">)</span>
  <span class="n">stride</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">()</span>
  <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="n">nmatrix</span><span class="p">.</span><span class="nf">dim</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="n">stride</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">...</span><span class="n">dim</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">j</span><span class="o">|</span>
      <span class="n">stride</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">nmatrix</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">stride</span>
<span class="k">end</span>
</code></pre></div></div>

<p>NMatrix#[] and NMatrix#[]= are thus able to read and write the elements of a matrix. NMatrix#MRI uses the @s object which stores the stride when the nmatrix is initialised.</p>

<p>NMatrix#[] calls the #xslice operator which calls  #get_slice operator that use the stride to find out whether we are accessing a single element or multiple elements. If  there are multiple elements #dense_storage_get then returns an NMatrix object with the elements along the dimension.</p>

<p>NMatrix-MRI differs from NMatrix-JRuby implementation as it makes sure that memory is properly utilized as the memory needs to be properly garbage collected.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">xslice</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="kp">nil</span>

  <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="nf">dim</span> <span class="o">&lt;</span> <span class="n">args</span><span class="p">.</span><span class="nf">length</span>
    <span class="k">raise</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">,</span><span class="s2">"wrong number of arguments\
       (</span><span class="si">#{</span><span class="n">args</span><span class="si">}</span><span class="s2"> for </span><span class="si">#{</span><span class="n">effective_dim</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">result</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">()</span>
    <span class="n">slice</span> <span class="o">=</span> <span class="n">get_slice</span><span class="p">(</span><span class="vi">@dim</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="vi">@shape</span><span class="p">)</span>
    <span class="n">stride</span> <span class="o">=</span> <span class="n">get_stride</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">slice</span><span class="p">[</span><span class="ss">:single</span><span class="p">]</span>
      <span class="k">if</span> <span class="p">(</span><span class="vi">@dtype</span> <span class="o">==</span> <span class="ss">:object</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="vi">@s</span><span class="p">[</span><span class="n">dense_storage_get</span><span class="p">(</span><span class="n">slice</span><span class="p">,</span><span class="n">stride</span><span class="p">)]</span>
      <span class="k">else</span>
        <span class="n">s</span> <span class="o">=</span> <span class="vi">@s</span><span class="p">.</span><span class="nf">toArray</span><span class="p">().</span><span class="nf">to_a</span>
        <span class="n">result</span> <span class="o">=</span> <span class="vi">@s</span><span class="p">.</span><span class="nf">getEntry</span><span class="p">(</span><span class="n">dense_storage_get</span><span class="p">(</span><span class="n">slice</span><span class="p">,</span><span class="n">stride</span><span class="p">))</span>
      <span class="k">end</span>
    <span class="k">else</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">dense_storage_get</span><span class="p">(</span><span class="n">slice</span><span class="p">,</span><span class="n">stride</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="k">return</span> <span class="n">result</span>
<span class="k">end</span>
</code></pre></div></div>

<p>NMatrix#[]= calls the #dense_storage_set operator which calls #get_slice operator that use the stride to find out whether we are accessing a single element or multiple elements. If there are multiple elements #set_slice recursively sets the elements of the matrix then returns an NMatrix object with the elements along the dimension.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dense_storage_set</span><span class="p">(</span><span class="n">slice</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="n">stride</span> <span class="o">=</span> <span class="n">get_stride</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
    <span class="n">v_size</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">right</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">NMatrix</span><span class="p">)</span>
      <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">.</span><span class="nf">s</span><span class="p">.</span><span class="nf">toArray</span><span class="p">.</span><span class="nf">to_a</span>
    <span class="k">end</span>

    <span class="k">if</span><span class="p">(</span><span class="n">right</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Array</span><span class="p">))</span>
      <span class="n">v_size</span> <span class="o">=</span> <span class="n">right</span><span class="p">.</span><span class="nf">length</span>
      <span class="n">v</span> <span class="o">=</span> <span class="n">right</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dtype</span> <span class="o">==</span> <span class="ss">:object</span><span class="p">)</span>
        <span class="c1"># nm_register_values(reinterpret_cast&lt;VALUE*&gt;(v), v_size)</span>
      <span class="k">end</span>

      <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="n">v_size</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
        <span class="n">v</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
      <span class="k">end</span>
    <span class="k">else</span>
      <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="n">right</span><span class="p">]</span>
      <span class="k">if</span> <span class="p">(</span><span class="vi">@dtype</span> <span class="o">==</span> <span class="ss">:object</span><span class="p">)</span>
        <span class="c1"># nm_register_values(reinterpret_cast&lt;VALUE*&gt;(v), v_size)</span>
      <span class="k">end</span>
    <span class="k">end</span>
    <span class="k">if</span><span class="p">(</span><span class="n">slice</span><span class="p">[</span><span class="ss">:single</span><span class="p">])</span>
      <span class="c1"># reinterpret_cast&lt;D*&gt;(s-&gt;elements)[nm_dense_storage_pos(s, slice-&gt;coords)] = v;</span>
      <span class="n">pos</span> <span class="o">=</span> <span class="n">dense_storage_pos</span><span class="p">(</span><span class="n">slice</span><span class="p">[</span><span class="ss">:coords</span><span class="p">],</span><span class="n">stride</span><span class="p">)</span>
      <span class="k">if</span> <span class="vi">@dtype</span> <span class="o">==</span> <span class="ss">:object</span>
        <span class="vi">@s</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">else</span>
        <span class="vi">@s</span><span class="p">.</span><span class="nf">setEntry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">end</span>
    <span class="k">else</span>
      <span class="n">v_offset</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">dest</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="n">dest</span><span class="p">[</span><span class="ss">:stride</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_stride</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
      <span class="n">dest</span><span class="p">[</span><span class="ss">:shape</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span>
      <span class="c1"># dest[:elements] = @s.toArray().to_a</span>
      <span class="n">dense_pos</span> <span class="o">=</span> <span class="n">dense_storage_pos</span><span class="p">(</span><span class="n">slice</span><span class="p">[</span><span class="ss">:coords</span><span class="p">],</span><span class="n">stride</span><span class="p">)</span>
      <span class="n">slice_set</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">slice</span><span class="p">[</span><span class="ss">:lengths</span><span class="p">],</span> <span class="n">dense_pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v_size</span><span class="p">,</span> <span class="n">v_offset</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<h2 id="enumerators"><strong>Enumerators</strong></h2>

<p>NMatrix-MRI uses the C code for enumerating the elements of a matrix. However, the NMatrix-JRuby uses pure Ruby code. Currently, all the enumerators for dense matrices with real data-type have been implemented and they are properly functional.
We haven’t implemented enumerators for objects currently.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">each_with_indices</span>
  <span class="n">nmatrix</span> <span class="o">=</span> <span class="n">create_dummy_nmatrix</span>
  <span class="n">stride</span> <span class="o">=</span> <span class="n">get_stride</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
  <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="c1">#Create indices and initialize them to zero</span>
  <span class="n">coords</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">dim</span><span class="p">){</span> <span class="mi">0</span> <span class="p">}</span>

  <span class="n">shape_copy</span> <span class="o">=</span>  <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
  <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="n">size</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="o">|</span>
    <span class="n">dense_storage_coords</span><span class="p">(</span><span class="n">nmatrix</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
    <span class="n">slice_index</span> <span class="o">=</span> <span class="n">dense_storage_pos</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">stride</span><span class="p">)</span>
    <span class="n">ary</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span>
    <span class="k">if</span> <span class="p">(</span><span class="vi">@dtype</span> <span class="o">==</span> <span class="ss">:object</span><span class="p">)</span>
      <span class="n">ary</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">.</span><span class="nf">s</span><span class="p">[</span><span class="n">slice_index</span><span class="p">]</span>
    <span class="k">else</span>
      <span class="n">ary</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">.</span><span class="nf">s</span><span class="p">.</span><span class="nf">toArray</span><span class="p">.</span><span class="nf">to_a</span><span class="p">[</span><span class="n">slice_index</span><span class="p">]</span>
    <span class="k">end</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="n">dim</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
      <span class="n">ary</span> <span class="o">&lt;&lt;</span> <span class="n">coords</span><span class="p">[</span><span class="nb">p</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="c1"># yield the array which now consists of the value and the indices</span>
    <span class="k">yield</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
  <span class="k">end</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="n">nmatrix</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="vi">@s</span>

  <span class="k">return</span> <span class="n">nmatrix</span>
 <span class="k">end</span>
</code></pre></div></div>

<h2 id="two-dimensional-matrices"><strong>Two Dimensional Matrices</strong></h2>

<p>Linear algebra is mostly about two-dimensional matrices. In NMatrix, when performing calculations in a two-dimensional matrix, a flat array is converted to a two-dimensional matrix. A two-dimensional matrix is stored as a BlockRealMatix or Array2DRowRealMatrix. Each of them has its own advantages.</p>

<p>Getting a two-d-matrix</p>

<p><img src="/assets/report/matrixGenerate.png?raw=true" alt="Alt Getting a two-d-matrix" title="Fig.2. Getting a two-d-matrix" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MatrixGenerator</span>
<span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">double</span><span class="o">[][]</span> <span class="nf">getMatrixDouble</span><span class="o">(</span><span class="kt">double</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span>
  <span class="o">{</span>
    <span class="kt">double</span><span class="o">[][]</span> <span class="n">matrix</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
            <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span> <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
            <span class="n">index</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">matrix</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Flat a two-d matrix</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayGenerator</span>
<span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">double</span><span class="o">[]</span> <span class="nf">getArrayDouble</span><span class="o">(</span><span class="kt">double</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span>
  <span class="o">{</span>
    <span class="kt">double</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">col</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
            <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="n">index</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Why use java method instead of Ruby method?</p>

<ol>
  <li>
    <p>Memory Usage and Garbage Collection =&gt; A scientific library is memory intensive and hence, every step counts.
 JRuby interpreter doesn’t need to dynamically guess the data type and uses less memory, i.e around 10 times. If the memory is properly utilized; when the GC kicks in, it has to clear less memory and improves the speed.</p>
  </li>
  <li>
    <p>Speed =&gt; Using java method greatly improves the speed around 1000 times, when compared to using ruby method.</p>
  </li>
</ol>

<h2 id="operators"><strong>Operators</strong></h2>

<p>All the operators from NMatrix-MRI have been implemented except moduli. The binary operators were easily implemented through Commons Math Api.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">+</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">create_dummy_nmatrix</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">NMatrix</span><span class="p">))</span>
    <span class="c1">#check dimension</span>
    <span class="k">raise</span><span class="p">(</span><span class="no">ShapeError</span><span class="p">,</span> <span class="s2">"Cannot add matrices with different dimension"</span><span class="p">)\</span>
    <span class="k">if</span> <span class="p">(</span><span class="vi">@dim</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="nf">dim</span><span class="p">)</span>
    <span class="c1">#check shape</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="n">dim</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
      <span class="k">raise</span><span class="p">(</span><span class="no">ShapeError</span><span class="p">,</span> <span class="s2">"Cannot add matrices with different shapes"</span><span class="p">)</span> <span class="p">\</span>
      <span class="k">if</span> <span class="p">(</span><span class="vi">@shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">end</span>
    <span class="n">result</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="vi">@s</span><span class="p">.</span><span class="nf">copy</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">s</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">result</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="vi">@s</span><span class="p">.</span><span class="nf">copy</span><span class="p">.</span><span class="nf">mapAddToSelf</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">result</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Trigonometric, exponentiation and log operators with a singular argument i.e. matrix elements were implemented using mapToSelf method that that takes univariate function as an argument. mapToSelf maps every element of ArrayRealVector to the Univate operator passed to it and returns self object.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sin</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">create_dummy_nmatrix</span>
  <span class="n">result</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="vi">@s</span><span class="p">.</span><span class="nf">copy</span><span class="p">.</span><span class="nf">mapToSelf</span><span class="p">(</span><span class="no">Sin</span><span class="p">.</span><span class="nf">new</span><span class="p">())</span>
  <span class="n">result</span>
<span class="k">end</span>
</code></pre></div></div>

<p>NMatrix#method(arg) was implemented using Bivariate functions provided by Commons-Maths and Java Maths library.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gamma</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">create_dummy_nmatrix</span>
  <span class="n">result</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="no">ArrayRealVector</span><span class="p">.</span><span class="nf">new</span> <span class="no">MathHelper</span><span class="p">.</span><span class="nf">gamma</span><span class="p">(</span><span class="vi">@s</span><span class="p">.</span><span class="nf">toArray</span><span class="p">)</span>
  <span class="n">result</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.apache.commons.math3.special.Gamma</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MathHelper</span><span class="o">{</span>
  <span class="o">...</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">double</span><span class="o">[]</span> <span class="nf">gamma</span><span class="o">(</span><span class="kt">double</span><span class="o">[]</span> <span class="n">arr</span><span class="o">){</span>
    <span class="kt">double</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
      <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Gamma</span><span class="o">.</span><span class="na">gamma</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="decomposition"><strong>Decomposition</strong></h2>

<p>NMatrix-MRI relies on LAPACKE and ATLAS for matrix decomposition and solve functionalities. Apache Commons Math provides a different set of API for decomposing a matrix and solving an equation. for-example potrf and other LAPACKE specific functions have not been implemented as they are not required at all.</p>

<p>Calculating determinant in NMatrix is tricky where a matrix is reduced either a Lower or Upper matrix and the diagonal elements of the matrix are multiplied to get the result. Also, the correct sign of the result whether positive or negative is taken into account, while calculating the determinanat. However, NMatrix-JRuby uses commons-math api to calculate the determinant.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">det_exact</span>
  <span class="k">if</span> <span class="p">(</span><span class="vi">@dim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="vi">@shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="vi">@shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">raise</span><span class="p">(</span><span class="no">ShapeError</span><span class="p">,</span> <span class="s2">"matrices must be square to have a determinant defined"</span><span class="p">)</span>
    <span class="k">return</span> <span class="kp">nil</span>
  <span class="k">end</span>
  <span class="n">to_return</span> <span class="o">=</span> <span class="no">LUDecomposition</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">twoDMat</span><span class="p">).</span><span class="nf">getDeterminant</span><span class="p">()</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Given below is the code, that shows how Cholesky decomposition has been implemented by using Commons Math API. Similarly, LU Decomposition and QR factorization have been implemented.</p>

<p><strong>Cholesky Decomposition</strong></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">factorize_cholesky</span>
    <span class="n">cholesky</span> <span class="o">=</span> <span class="no">CholeskyDecomposition</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">twoDMat</span><span class="p">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">create_dummy_nmatrix</span>
    <span class="n">twoDMat</span> <span class="o">=</span> <span class="n">cholesky</span><span class="p">.</span><span class="nf">getL</span>
    <span class="n">l</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="no">ArrayRealVector</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ArrayGenerator</span><span class="p">.</span><span class="nf">getArrayDouble</span><span class="p">\</span>
        <span class="p">(</span><span class="n">twoDMat</span><span class="p">.</span><span class="nf">getData</span><span class="p">,</span> <span class="vi">@shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="vi">@shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">create_dummy_nmatrix</span>
    <span class="n">twoDMat</span> <span class="o">=</span> <span class="n">cholesky</span><span class="p">.</span><span class="nf">getLT</span>
    <span class="n">u</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="no">ArrayRealVector</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ArrayGenerator</span><span class="p">.</span><span class="nf">getArrayDouble</span><span class="p">\</span>
      <span class="p">(</span><span class="n">twoDMat</span><span class="p">.</span><span class="nf">getData</span><span class="p">,</span> <span class="vi">@shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="vi">@shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">l</span><span class="p">]</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Cholesky Decomposition for an NMatrix-JRuby requires the matrix to be square matrix.</p>

<p><strong>LUDecomposition</strong></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">factorize_lu</span> <span class="n">with_permutation_matrix</span><span class="o">=</span><span class="kp">nil</span>
    <span class="k">raise</span><span class="p">(</span><span class="no">NotImplementedError</span><span class="p">,</span> <span class="s2">"only implemented for dense storage"</span><span class="p">)\</span>
       <span class="k">unless</span> <span class="nb">self</span><span class="p">.</span><span class="nf">stype</span> <span class="o">==</span> <span class="ss">:dense</span>
    <span class="k">raise</span><span class="p">(</span><span class="no">NotImplementedError</span><span class="p">,</span> <span class="s2">"matrix is not 2-dimensional"</span><span class="p">)\</span>
       <span class="k">unless</span> <span class="nb">self</span><span class="p">.</span><span class="nf">dimensions</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">clone</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">create_dummy_nmatrix</span>
    <span class="n">twoDMat</span> <span class="o">=</span> <span class="no">LUDecomposition</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">twoDMat</span><span class="p">).</span><span class="nf">getP</span>
    <span class="n">pivot</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="no">ArrayRealVector</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ArrayGenerator</span><span class="p">.</span><span class="nf">getArrayDouble</span><span class="p">\</span>
    <span class="p">(</span><span class="n">twoDMat</span><span class="p">.</span><span class="nf">getData</span><span class="p">,</span> <span class="vi">@shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="vi">@shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">pivot</span><span class="p">]</span>
  <span class="k">end</span>
</code></pre></div></div>

<p><strong>QRFactorization</strong></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">factorize_qr</span>
    <span class="k">raise</span><span class="p">(</span><span class="no">NotImplementedError</span><span class="p">,</span> <span class="s2">"only implemented for dense storage"</span><span class="p">)\</span>
       <span class="k">unless</span> <span class="nb">self</span><span class="p">.</span><span class="nf">stype</span> <span class="o">==</span> <span class="ss">:dense</span>
    <span class="k">raise</span><span class="p">(</span><span class="no">ShapeError</span><span class="p">,</span> <span class="s2">"Input must be a 2-dimensional matrix to have\
       a QR decomposition"</span><span class="p">)</span> <span class="k">unless</span> <span class="nb">self</span><span class="p">.</span><span class="nf">dim</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="n">qrdecomp</span> <span class="o">=</span> <span class="no">QRDecomposition</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">twoDMat</span><span class="p">)</span>

    <span class="n">qmat</span> <span class="o">=</span> <span class="n">create_dummy_nmatrix</span>
    <span class="n">qtwoDMat</span> <span class="o">=</span> <span class="n">qrdecomp</span><span class="p">.</span><span class="nf">getQ</span>
    <span class="n">qmat</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="no">ArrayRealVector</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ArrayGenerator</span><span class="o">.</span><span class="p">\</span>
      <span class="n">getArrayDouble</span><span class="p">(</span><span class="n">qtwoDMat</span><span class="p">.</span><span class="nf">getData</span><span class="p">,</span> <span class="vi">@shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="vi">@shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">rmat</span> <span class="o">=</span> <span class="n">create_dummy_nmatrix</span>
    <span class="n">rtwoDMat</span> <span class="o">=</span> <span class="n">qrdecomp</span><span class="p">.</span><span class="nf">getR</span>
    <span class="n">rmat</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="no">ArrayRealVector</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ArrayGenerator</span><span class="o">.</span><span class="p">\</span>
      <span class="n">getArrayDouble</span><span class="p">(</span><span class="n">rtwoDMat</span><span class="p">.</span><span class="nf">getData</span><span class="p">,</span> <span class="vi">@shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="vi">@shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">qmat</span><span class="p">,</span><span class="n">rmat</span><span class="p">]</span>

  <span class="k">end</span>
</code></pre></div></div>

<p><strong>NMatrix#solve</strong></p>

<p>The solve method currently uses LUDecomposition and Cholesky Decomposition for solving the equations.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">opts</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="k">raise</span><span class="p">(</span><span class="no">ShapeError</span><span class="p">,</span> <span class="s2">"Must be called on square matrix"</span><span class="p">)\</span>
       <span class="k">unless</span> <span class="nb">self</span><span class="p">.</span><span class="nf">dim</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nb">self</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">self</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">raise</span><span class="p">(</span><span class="no">ShapeError</span><span class="p">,</span> <span class="s2">"number of rows of b must equal number\
       of cols of self"</span><span class="p">)</span> <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">raise</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">"only works with dense matrices"</span><span class="p">)</span> <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="nf">stype</span> <span class="o">!=</span> <span class="ss">:dense</span>
    <span class="k">raise</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">"only works for non-integer, non-object dtypes"</span><span class="p">)\</span>
       <span class="k">if</span> <span class="n">integer_dtype?</span> <span class="n">or</span> <span class="n">object_dtype?</span> <span class="n">or</span> <span class="n">b</span><span class="p">.</span><span class="nf">integer_dtype?</span> <span class="n">or</span> <span class="n">b</span><span class="p">.</span><span class="nf">object_dtype?</span>

    <span class="n">opts</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">form: :general</span> <span class="p">}.</span><span class="nf">merge</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
    <span class="n">x</span>    <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="nf">clone</span>
    <span class="n">n</span>    <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nrhs</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">nmatrix</span> <span class="o">=</span> <span class="n">create_dummy_nmatrix</span>
    <span class="k">case</span> <span class="n">opts</span><span class="p">[</span><span class="ss">:form</span><span class="p">]</span>
    <span class="k">when</span> <span class="ss">:general</span><span class="p">,</span> <span class="ss">:upper_tri</span><span class="p">,</span> <span class="ss">:upper_triangular</span><span class="p">,</span> <span class="ss">:lower_tri</span><span class="p">,</span> <span class="ss">:lower_triangular</span>
      <span class="c1">#LU solver</span>
      <span class="n">solver</span> <span class="o">=</span> <span class="no">LUDecomposition</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">twoDMat</span><span class="p">).</span><span class="nf">getSolver</span>
      <span class="n">nmatrix</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="nf">s</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">nmatrix</span>
    <span class="k">when</span> <span class="ss">:pos_def</span><span class="p">,</span> <span class="ss">:positive_definite</span>
      <span class="n">solver</span> <span class="o">=</span> <span class="no">Choleskyecomposition</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">twoDMat</span><span class="p">).</span><span class="nf">getSolver</span>
      <span class="n">nmatrix</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="nf">s</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">nmatrix</span>
    <span class="k">else</span>
      <span class="k">raise</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">"</span><span class="si">#{</span><span class="n">opts</span><span class="p">[</span><span class="ss">:form</span><span class="p">]</span><span class="si">}</span><span class="s2"> is not a valid form option"</span><span class="p">)</span>
    <span class="k">end</span>

  <span class="k">end</span>
</code></pre></div></div>

<p><strong>NMatrix#matrix_solve</strong></p>

<p>Given we need to solved a system of linear equations</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    AX = B where A is an m×n matrix, B and X are n×p matrices, we needed to solve this equation by iterating through B.
</code></pre></div></div>

<p>NMatrix-MRI implements this functionality using NMatrix::BLAS::cblas_trsm operator. However, for NMatrix-JRuby, we implemented NMatrix#matrix_solve.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">matrix_solve</span> <span class="n">rhs</span>
    <span class="k">if</span> <span class="n">rhs</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span>
      <span class="n">nmatrix</span> <span class="o">=</span> <span class="no">NMatrix</span><span class="p">.</span><span class="nf">new</span> <span class="ss">:copy</span>
      <span class="n">nmatrix</span><span class="p">.</span><span class="nf">shape</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="nf">shape</span>
      <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="c1">#Solve a matrix and store the vectors in a matrix</span>
      <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="n">rhs</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
        <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="nf">col</span><span class="p">(</span><span class="n">i</span><span class="p">)).</span><span class="nf">s</span><span class="p">.</span><span class="nf">toArray</span><span class="p">.</span><span class="nf">to_a</span>
      <span class="k">end</span>
      <span class="c1">#res is in col major format</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">ArrayGenerator</span><span class="p">.</span><span class="nf">getArrayColMajorDouble</span> <span class="p">\</span>
         <span class="n">res</span><span class="p">.</span><span class="nf">to_java</span> <span class="ss">:double</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rhs</span><span class="p">.</span><span class="nf">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="n">nmatrix</span><span class="p">.</span><span class="nf">s</span> <span class="o">=</span> <span class="no">ArrayRealVector</span><span class="p">.</span><span class="nf">new</span> <span class="n">result</span>

      <span class="k">return</span> <span class="n">nmatrix</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="nf">solve</span> <span class="n">rhs</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Currently, Hessenberg transformation for an NMatix has not been implemented.</p>

<h2 id="other-dtypes"><strong>Other dtypes</strong></h2>

<p>We have tried implementing float dtypes using jblas FloatMatrix. We here used jblas instead of commons math as Commons Math uses Field Elements for Floats and we may have faced issues with Reflection and TypeErasure. However, we had issues with precision.</p>

<h2 id="code-organisation-and-deployment"><strong>Code Organisation and Deployment</strong></h2>

<p>To minimise conflict with the MRI codebase all the ruby code has been placed in /lib/nmatrix/jruby directory. /lib/nmatrix/nmatrix.rb decides whether to load nmatrix.so or nmatrix_jruby.rb after detecting the Ruby Platform.</p>

<p>The added advantage of this is at run-time the ruby interpreter must not decide which function to call. The impact on performance can be seen when running programs which intensively use NMatrix for linear algebraic computations(e.g. mixed-models).</p>

<h2 id="performance"><strong>Performance</strong></h2>
<p>We have benchmarked some of the NMatrix functionalities. The following plots compare the performance between NMatrix-JRuby, NMatrix-MRI and NMatrix-MRI using LAPACKE/ATLAS libraries.</p>

<p>The lower the slope of the curve, the better is the performance.</p>

<p>Note:</p>

<ol>
  <li>Addition and subtraction are not supported by LAPACKE/ATLAS.</li>
  <li>NMatrix - MRI relies on LAPACKE/ATLAS for calculating determinants and LU Decomposition(lud).</li>
</ol>

<p><img src="/assets/report/plots/add.png?raw=true" alt="Alt Matrix Addition" title="Fig.3. Matrix Addition" />
<img src="/assets/report/plots/subtract.png?raw=true" alt="Alt Matrix Subtraction" title="Fig.4. Matrix Subtraction" />
<img src="/assets/report/plots/mult.png?raw=true" alt="Alt Matrix Multiplication" title="Fig.5. Matrix Multiplication" />
<img src="/assets/report/plots/gamma.png?raw=true" alt="Alt Gamma operator" title="Fig.6. Gamma Operator" />
<img src="/assets/report/plots/determinant.png?raw=true" alt="Alt Determinant" title="Fig.7. Determinant" />
<img src="/assets/report/plots/lud.png?raw=true" alt="Alt LU Facorization" title="Fig.8. LU Facorization" /></p>

<p><strong>Result:</strong></p>

<ol>
  <li>
    <p>For, two dimensional matrices, NMatrix-JRuby is currently slower than NMatrix-MRI for matrix multiplication, and matrix decomposition functionalities(calculating determinant and factorizing a matrix). NMatrix-JRuby is faster than NMatrix-MRI for other functionalities of a two dimensional matrix, like addition, subtraction, trigonometic operations, etc.</p>
  </li>
  <li>
    <p>NMatrix-JRuby is a clear winner when we are working with matrices of arbitrary dimension.</p>
  </li>
</ol>

<h2 id="test-report"><strong>Test Report</strong></h2>

<table>
  <thead>
    <tr>
      <th>Spec file</th>
      <th style="text-align: center">Total Tests</th>
      <th style="text-align: center">Success</th>
      <th style="text-align: center">Failure</th>
      <th style="text-align: center">Pending</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>00_nmatrix_spec</td>
      <td style="text-align: center">188</td>
      <td style="text-align: center">139</td>
      <td style="text-align: center">43</td>
      <td style="text-align: center">6</td>
    </tr>
    <tr>
      <td>01_enum_spec</td>
      <td style="text-align: center">17</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">09</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td>02_slice_spec</td>
      <td style="text-align: center">144</td>
      <td style="text-align: center">116</td>
      <td style="text-align: center">28</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td>03_nmatrix_monkeys_spec</td>
      <td style="text-align: center">12</td>
      <td style="text-align: center">11</td>
      <td style="text-align: center">01</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td>elementwise_spec</td>
      <td style="text-align: center">38</td>
      <td style="text-align: center">21</td>
      <td style="text-align: center">17</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td>homogeneous_spec.rb</td>
      <td style="text-align: center">07</td>
      <td style="text-align: center">06</td>
      <td style="text-align: center">01</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td>math_spec</td>
      <td style="text-align: center">737</td>
      <td style="text-align: center">541</td>
      <td style="text-align: center">196</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td>shortcuts_spec</td>
      <td style="text-align: center">81</td>
      <td style="text-align: center">57</td>
      <td style="text-align: center">24</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td>stat_spec</td>
      <td style="text-align: center">72</td>
      <td style="text-align: center">40</td>
      <td style="text-align: center">32</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td>slice_set_spec</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">04</td>
      <td style="text-align: center">0</td>
    </tr>
  </tbody>
</table>

<p><br />
Why some tests fail?</p>

<ol>
  <li>Complex dtype has not been implemented.</li>
  <li>Sparse matrices (list and yale) have not been implemented.</li>
  <li>Decomposition methods that are specific to LAPACK and ATLAS have not been implemented.</li>
  <li>Integer dtype not properly assigned to Floor, Ceil and Round.</li>
</ol>

<h2 id="conclusion"><strong>Conclusion</strong></h2>
<p>The main goal of this project was to bring  <strong>Scientific Computation to JRuby</strong>, to gain from the performance JRuby offers.</p>

<p>By the end of the GSoC, we have been able to successfully create a linear algebra library, NMatrix for JRuby users, which they can easily run on their machines unless they want to use Complex numbers.</p>

<p>We have mixed-models gem simultaneously ported to JRuby. Even here, we are very close to MRI if performance is considered.</p>

<p><strong>Future work</strong></p>

<p>In the coming months we would be implementing Sparse Matrices, thus making NMatrix a complete package for JRuby users. We would also work on improving performance using parallelization.
We also feel that JRuby lacks its own Jupyter notebook. The iruby notebook doesn’t work for JRuby. To create an amazing experience for scientific computation on JRuby, we will be porting iruby to  JRuby.</p>

<h2 id="acknowledgements"><strong>Acknowledgements</strong></h2>

<p>I would like to express my sincere gratitude to my mentor Pjotr Prins for the continuous support through the summers, and for his patience, motivation, enthusiasm, and immense knowledge. I could not have imagined having a better advisor and mentor, for this project.</p>

<p>I am very grateful to Google and the Ruby Science Foundation for this golden opportunity.</p>

<p>I am very thankful to Charles Nutter, John Woods, Sameer Deshmukh, Kenta Murata and Alexej Gossmann, who mentored me through the project. It has been a great learning experience.</p>

<p>I thank my fellow GSoC participants Rajith, Lokesh and Gaurav who helped me with certain aspects of my project.</p>

<div id="disqus_thread"></div>
<script>
/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//prasunanandblog.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</p>
              </div>
            </div>

            <div class="related-blog-wraper wow fadeInUp">
              <h6>Related Blog</h6>

              

              <div class="related-blog-item latest-post-item wow fadeInUp" data-wow-delay="0.1s">
                <a href="/cuda/opencl/ruby/rbcuda/2018/02/24/rubygrant17-rbcuda-installation-and-architecture.html.html">
                  <div class="latest-post-item-image">
                    <img src="/images/banner.png" alt="#">
                  </div>
                  <div class="latest-post-item-content">
                    <h2>RbCUDA: Installation and Architecture</h2>
                    <span>24 February 2018</span>
                  </div>
                </a>
              </div>
              

              <div class="related-blog-item latest-post-item wow fadeInUp" data-wow-delay="0.1s">
                <a href="/cuda/opencl/ruby/rbcuda/2017/12/30/rubygrant17-rbcuda-introduction.html.html">
                  <div class="latest-post-item-image">
                    <img src="/images/banner.png" alt="#">
                  </div>
                  <div class="latest-post-item-content">
                    <h2>RbCUDA: CUDA bindings for Ruby</h2>
                    <span>30 December 2017</span>
                  </div>
                </a>
              </div>
              

            </div>
          </div>
          

          <div class="col-12 col-md-12 col-lg-3">
            <div class="blog-page-right-wraper">
              <div class="search-wraper wow fadeInUp" data-wow-delay="0.2s">
                <h6>Search</h6>
                <div class="search-form-wraper">
                  <form action="/search.html" method="GET">
                    <input type="text" name="query" id="search-box" placeholder="Search">
                    <button class="btn-bg"><img src="/images/icons/search.svg" alt="#"></button>
                  </form>
                </div>
              </div>

              <div class="latest-post-wraper wow fadeInUp" data-wow-delay="0.3s">
                <h6>Latest Post</h6>
                
                <div class="latest-post-item wow fadeInUp" data-wow-delay="0.1s">
                  <a href="/cuda/opencl/ruby/rbcuda/2018/02/24/rubygrant17-rbcuda-installation-and-architecture.html">
                    <div class="latest-post-item-image">
                      <img src="/images/banner.png" alt="#">
                    </div>
                    <div class="latest-post-item-content">
                      <h2>RbCUDA: Installation and Architecture</h2>
                      <span>24 February 2018</span>
                    </div>
                  </a>
                </div>

                
                <div class="latest-post-item wow fadeInUp" data-wow-delay="0.1s">
                  <a href="/cuda/opencl/ruby/rbcuda/2017/12/30/rubygrant17-rbcuda-introduction.html">
                    <div class="latest-post-item-image">
                      <img src="/images/banner.png" alt="#">
                    </div>
                    <div class="latest-post-item-content">
                      <h2>RbCUDA: CUDA bindings for Ruby</h2>
                      <span>30 December 2017</span>
                    </div>
                  </a>
                </div>

                
                <div class="latest-post-item wow fadeInUp" data-wow-delay="0.1s">
                  <a href="/arrayfire/cuda/opencl/ruby/2017/08/28/gsoc17-project-report.html">
                    <div class="latest-post-item-image">
                      <img src="/images/banner.png" alt="#">
                    </div>
                    <div class="latest-post-item-content">
                      <h2>GSoC 2017: Creating the fastest math libraries for Ruby by using the GPU through OpenCL and ArrayFire.</h2>
                      <span>28 August 2017</span>
                    </div>
                  </a>
                </div>

                
              </div>

              <div class="tags-wraper wow fadeInUp" data-wow-delay="0.4s">
                <h6>Tag Clouds</h6>
                <div class="tag-clouds">
                  <a href="#">Engineering</a>
                  <a href="#">Infrastructure</a>
                  <a href="#">Technology</a>
                  <a href="#">Future</a>
                  <a href="#">Infrastructure</a>
                  <a href="#">Future</a>
                  <a href="#">Engineering</a>
                  <a href="#">Technology</a>
                  <a href="#">Engineering</a>
                  <a href="#">Infrastructure</a>
                  <a href="#">Technology</a>
                  <a href="#">Future</a>
                </div>
              </div>

            </div>
          </div>



        </div>
      </div>
    </section>

    <section id="updates">
      <div class="container">
        <div class="row">
          <div class="col-12">
            <div class="updates-wraper">
              <div class="updates-image wow fadeInUp" data-wow-delay="0.2s">
                <img src="/images/image2.svg" alt="#">
              </div>
              <div class="updates-form header-form wow fadeInUp" data-wow-delay="0.2s">
                <h5 class="font-h5">Subscribe for exclusive</h5>
                <h3 class="font-h3">news and updates!</h3>
                <form action="https://zasper.io/newsletter" method="POST">
                  <div class="form-group">
                    <input type="email" name="email" placeholder="Enter your email">
                    <button type="submit" class="btn-bg hover-bg">Subscribe</button>
                  </div>
                </form>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="footer">
      <div class="container">
        <div class="row">
          <div class="col-12 col-md-4">
            <div class="footer-info wow fadeInUp" data-wow-delay="0.2s">
              <div class="footer-image wow fadeInUp" data-wow-delay="0.1s">
                <img src="/images/logo.svg" alt="#">
              </div>
              <div class="footer-content wow fadeInUp" data-wow-delay="0.2s">
                <p>Zasper strives to be at the forefront of the AI Revolution that is taking place around the world. We want to ease the pain of Data teams by enabling them to develop and deploy their AI solutions right from rapid prototyping to shipping into production.</p>
              </div>
              <div class="footer-social wow fadeInUp" data-wow-delay="0.3s">
                <a href="https://www.linkedin.com/company/zasper"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
                <a href="#"><i class="fa fa-twitter" aria-hidden="true"></i></a>
                <a href="https://github.com/zasperio"><i class="fa fa-github" aria-hidden="true"></i></a>
              </div>
            </div>
          </div>
          <div class="col-12 col-md-8">
            <div class="footer-menu-wraper wow fadeInUp" data-wow-delay="0.4s">
              <div>
                <div class="footer-menu wow fadeInUp" data-wow-delay="0.1s">
                  <h6>Company</h6>
                  <a href="https://zasper.io/product">Product</a>
                  <a href="https://zasper.io/pricing">Pricing</a>
                  <a href="https://zasper.io/partners">Partners</a>
                  <a href="https://zasper.io/careers">Careers</a>
                  <a href="https://zasper.io/support">Support</a>
                </div>
              </div>
              <div>
                <div class="footer-menu wow fadeInUp" data-wow-delay="0.3s">
                  <h6>Solutions</h6>
                  <a href="https://zasper.io/solutions/banking">Banking</a>
                  <a href="https://zasper.io/solutions/telecom">Telecom</a>
                  <a href="https://zasper.io/solutions/oil-and-gas">Oil and Gas</a>
                  <a href="https://zasper.io/solutions/healthcare">Healthcare</a>
                  <a href="https://zasper.io/solutions/">View More</a>
                </div>
              </div>
              <div>
                <div class="footer-menu wow fadeInUp" data-wow-delay="0.5s">
                  <h6>Community</h6>
                  <a href="/">Blog</a>
                  <a href="https://docs.zasper.io">Docs</a>
                  <a href="https://zasper.io/contact-us">Contact Us</a>
                </div>
              </div>
              <div>
                <div class="footer-menu wow fadeInUp" data-wow-delay="0.6s">
                  <h6>Legal</h6>
                  <a href="https://zasper.io/terms-and-conditions">Terms and Conditions</a>
                  <a href="https://zasper.io/privacy">Privacy Policy</a>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="copyright">
      <div class="container">
        <div class="row">
          <div class="col-12">
            <div class="copyright-text wow fadeInUp" data-wow-delay="0.2s">
              <p>©2021 zasper ai labs pvt ltd | All rights reserved.</p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- JavaScripts -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/wow.min.js"></script>
    <script src="/js/owl.carousel.min.js"></script>
    <script src="/js/main.js"></script>

  </body>
</html>

